<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.11"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <link rel="stylesheet" href='http://fonts.googleapis.com/css?family=Exo+2:400,200,700' type='text/css'>
    <title>Project Chrono: IRRLICHT module</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
    <link href="main.css" rel="stylesheet" type="text/css" />
    <!--  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css"> -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
    <script type="text/javascript" src="bootstrap-hover-dropdown.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://projectchrono.org">
            <span class="logo first">PROJECT</span><span class="logo second">CHRONO</span>
        </a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li><a href="http://projectchrono.org/download">Download</a></li>
        <li class="dropdown">
            <a href="http://api.chrono.projectchrono.org" class="dropdown-toggle disabled" data-hover="dropdown" data-toggle="dropdown" data-delay="100" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu">
                <li><a href="http://api.chrono.projectchrono.org/faq_root.html">FAQ</a></li>
                <li><a href="http://api.chrono.projectchrono.org/tutorial_table_of_content_install.html">Install Guide</a></li>
                <li><a href="http://api.chrono.projectchrono.org/tutorial_root.html">Examples/Tutorials</a></li>
                <li><a href="http://api.chrono.projectchrono.org/model_root.html">Model Library</a></li>
                <li><a href="http://api.chrono.projectchrono.org/validation_studies_root.html">Validation Studies</a></li>
                <li><a href="http://api.chrono.projectchrono.org/whitepaper_root.html">White Papers</a></li>
                <li><a href="http://projectchrono.org/docpdf">PDF Version</a></li>
            </ul>
        </li>
        <li class="dropdown">
            <a href="http://projectchrono.org/gallery/" class="dropdown-toggle disabled" data-hover="dropdown" data-toggle="dropdown" data-delay="100" role="button" style="dropdown:hover" aria-haspopup="true" aria-expanded="false">Movies <span class="caret"></span></a>
            <ul class="dropdown-menu">
                <li><a href="http://projectchrono.org/gallery/">Gallery</a></li>
                <li><a href="http://sbel.wisc.edu/Animations/">SBEL</a></li>
                <li><a href="https://vimeo.com/uwsbel">On Vimeo</a></li>
            </ul>
        </li>
        <li><a href="http://projectchrono.org/news/">News</a></li>
        <li><a href="http://projectchrono.org/forum">Forum</a></li>
		<li class="dropdown">
            <a href="http://projectchrono.org/about/" class="dropdown-toggle disabled" data-hover="dropdown" data-toggle="dropdown" data-delay="100" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
            <ul class="dropdown-menu">
                <li><a href="http://projectchrono.org/about/">What is ProjectChrono</a></li>
                <li><a href="http://projectchrono.org/testimonials/">Users</a></li>
            </ul>
        </li>
        <li><a href="http://projectchrono.org/status">Status</a></li>            
            <li>
              <form method="get" action="http://projectchrono.org/search" id="search_bar_triggered">
                          <input type="submit" value="Search">
                <input type="text" id="search_bar" name="query" value="" />
              </form> 
            </li>
    </ul>
          <!-- <ul class="nav navbar-nav navbar-right">
      </ul> -->
  </div><!--/.navbar-collapse -->
</div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div class="content" id="content">
        <div class="container">
            <div class="row">
                <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                    <div style="margin-bottom: 15px;">
                        <!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">IRRLICHT module</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Runtime visualization with Irrlicht. </p>
<p>This module can be used to provide 3D realtime rendering in Chrono::Engine.</p>
<p>For additional information, see:</p><ul>
<li>the <a class="el" href="module_irrlicht_installation.html">installation guide</a></li>
<li>the <a class="el" href="tutorial_root.html">tutorials</a> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacechrono_1_1irrlicht"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechrono_1_1irrlicht.html">chrono::irrlicht</a></td></tr>
<tr class="memdesc:namespacechrono_1_1irrlicht"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace with classes for the Irrlicht module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html">chrono::irrlicht::ChBodySceneNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Irrlicht scene node for a body.  <a href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_app.html">chrono::irrlicht::ChIrrApp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to add some GUI to Irrlicht+Chrono::Engine applications.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_app.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_app_interface.html">chrono::irrlicht::ChIrrAppInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to add some GUI to Irrlicht + Chrono::Engine applications.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_app_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_asset_converter.html">chrono::irrlicht::ChIrrAssetConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class with static functions which allow creation of Irrlicht frequent 'scene nodes' like lights, camera, sky box etc.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_asset_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_r_t_s_camera.html">chrono::irrlicht::RTSCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to create an interactive videocamera in Irrlicht, that is similar to the Maya camera but hasn't the problems that the Maya camera has in Irrlicht 1.5.  <a href="classchrono_1_1irrlicht_1_1_r_t_s_camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_c_shader_preprocessor.html">chrono::irrlicht::CShaderPreprocessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchrono_1_1irrlicht_1_1_c_shader_preprocessor.html" title="CShaderPreprocessor. ">CShaderPreprocessor</a>.  <a href="classchrono_1_1irrlicht_1_1_c_shader_preprocessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_depth_shader_c_b.html">chrono::irrlicht::DepthShaderCB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchrono_1_1irrlicht_1_1_depth_shader_c_b.html" title="DepthShaderCB. ">DepthShaderCB</a>.  <a href="classchrono_1_1irrlicht_1_1_depth_shader_c_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_shadow_shader_c_b.html">chrono::irrlicht::ShadowShaderCB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchrono_1_1irrlicht_1_1_shadow_shader_c_b.html" title="ShadowShaderCB. ">ShadowShaderCB</a>.  <a href="classchrono_1_1irrlicht_1_1_shadow_shader_c_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_screen_quad_c_b.html">chrono::irrlicht::ScreenQuadCB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchrono_1_1irrlicht_1_1_screen_quad_c_b.html" title="ScreenQuadCB. ">ScreenQuadCB</a>.  <a href="classchrono_1_1irrlicht_1_1_screen_quad_c_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_c_screen_quad.html">chrono::irrlicht::CScreenQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchrono_1_1irrlicht_1_1_c_screen_quad.html" title="CScreenQuad. ">CScreenQuad</a>.  <a href="classchrono_1_1irrlicht_1_1_c_screen_quad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_effect_handler.html">chrono::irrlicht::EffectHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main effect handling class, use this to apply shadows and effects.  <a href="classchrono_1_1irrlicht_1_1_effect_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_node.html">chrono::irrlicht::ChIrrNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for Irrlicht visualization.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_node_asset.html">chrono::irrlicht::ChIrrNodeAsset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for adding Irrlicht visualization to a <a class="el" href="classchrono_1_1_ch_physics_item.html" title="Base class for items that can contain objects of ChVariables or ChConstraints, such as rigid bodies...">ChPhysicsItem</a>.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_node_asset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_node_proxy_to_asset.html">chrono::irrlicht::ChIrrNodeProxyToAsset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for proxy to <a class="el" href="classchrono_1_1_ch_asset.html" title="Classes for adding user data (such as rendering shapes, reference to files) to ChPhysicsItem objects...">ChAsset</a>, it is a node with mesh in Irrlicht system and a shared pointer to the <a class="el" href="classchrono_1_1_ch_asset.html" title="Classes for adding user data (such as rendering shapes, reference to files) to ChPhysicsItem objects...">ChAsset</a> to whom it corresponds.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_node_proxy_to_asset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_particles_scene_node.html">chrono::irrlicht::ChIrrParticlesSceneNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of an Irrlicht scene node for particles.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_particles_scene_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_tools.html">chrono::irrlicht::ChIrrTools</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class with static functions which help with the integration of Chrono::Engine and Irrlicht 3D rendering library.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_tools.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_wizard.html">chrono::irrlicht::ChIrrWizard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class with static functions which allow creation of Irrlicht frequent 'scene nodes' like lights, camera, sky box etc.  <a href="classchrono_1_1irrlicht_1_1_ch_irr_wizard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga8754b6a0992f4685acf63c8e3c82db51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8754b6a0992f4685acf63c8e3c82db51"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>E_SHADER_EXTENSION</b> { <b>ESE_GLSL</b>, 
<b>ESE_HLSL</b>, 
<b>ESE_COUNT</b>
 }</td></tr>
<tr class="separator:ga8754b6a0992f4685acf63c8e3c82db51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7e2f7bdfa610d6bbf8c7970d1f4eb3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga4d7e2f7bdfa610d6bbf8c7970d1f4eb3">chrono::irrlicht::E_SHADOW_MODE</a> { <br />
&#160;&#160;<b>ESM_RECEIVE</b>, 
<b>ESM_CAST</b>, 
<b>ESM_BOTH</b>, 
<b>ESM_EXCLUDE</b>, 
<br />
&#160;&#160;<b>ESM_COUNT</b>
<br />
 }<tr class="memdesc:ga4d7e2f7bdfa610d6bbf8c7970d1f4eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow mode enums, sets whether a node recieves shadows, casts shadows, or both.  <a href="group__irrlicht__module.html#ga4d7e2f7bdfa610d6bbf8c7970d1f4eb3">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga4d7e2f7bdfa610d6bbf8c7970d1f4eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6049603cfa127f42c6bbe78fa889d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf6049603cfa127f42c6bbe78fa889d8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gadf6049603cfa127f42c6bbe78fa889d8">chrono::irrlicht::E_FILTER_TYPE</a> { <br />
&#160;&#160;<b>EFT_NONE</b>, 
<b>EFT_4PCF</b>, 
<b>EFT_8PCF</b>, 
<b>EFT_12PCF</b>, 
<br />
&#160;&#160;<b>EFT_16PCF</b>, 
<b>EFT_COUNT</b>
<br />
 }<tr class="memdesc:gadf6049603cfa127f42c6bbe78fa889d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various filter types, up to 16 samples PCF. <br /></td></tr>
</td></tr>
<tr class="separator:gadf6049603cfa127f42c6bbe78fa889d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac6699f10e69950ed4297b873b702e6c9"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9">chrono::irrlicht::addChBodySceneNode</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, irr::scene::IAnimatedMesh *amesh, double mmass=1.0, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:gac6699f10e69950ed4297b873b702e6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> with given position of COG, inserts it into the Irrlicht scene etc.  <a href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9">More...</a><br /></td></tr>
<tr class="separator:gac6699f10e69950ed4297b873b702e6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ba3126f6cfe0dc572e1cb26749f551"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gab5ba3126f6cfe0dc572e1cb26749f551">chrono::irrlicht::addChBodySceneNode_offsetCOG</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, irr::scene::IAnimatedMesh *amesh, double mmass=1.0, const ChVector&lt;&gt; &amp;mesh_position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), const ChVector&lt;&gt; &amp;COG_offset=ChVector&lt;&gt;(0, 0, 0), irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:gab5ba3126f6cfe0dc572e1cb26749f551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but allow user to specify an offset distance between COG and mesh location.  <a href="group__irrlicht__module.html#gab5ba3126f6cfe0dc572e1cb26749f551">More...</a><br /></td></tr>
<tr class="separator:gab5ba3126f6cfe0dc572e1cb26749f551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga430a3c13a142d932ed9e7184d7c10455"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga430a3c13a142d932ed9e7184d7c10455">chrono::irrlicht::addChBodySceneNode_easySphere</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, double mmass=1.0, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), double mradius=1.0, int Hslices=15, int Vslices=8, irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga430a3c13a142d932ed9e7184d7c10455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a sphere, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier).  <a href="group__irrlicht__module.html#ga430a3c13a142d932ed9e7184d7c10455">More...</a><br /></td></tr>
<tr class="separator:ga430a3c13a142d932ed9e7184d7c10455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88caf7f14bd9e3ec92b5f4738e43441f"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga88caf7f14bd9e3ec92b5f4738e43441f">chrono::irrlicht::addChBodySceneNode_easyBox</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, double mmass=1.0, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), const ChVector&lt;&gt; &amp;size=ChVector&lt;&gt;(1, 1, 1), irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga88caf7f14bd9e3ec92b5f4738e43441f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a box, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier).  <a href="group__irrlicht__module.html#ga88caf7f14bd9e3ec92b5f4738e43441f">More...</a><br /></td></tr>
<tr class="separator:ga88caf7f14bd9e3ec92b5f4738e43441f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de6d881012e9d67a5ebd877baca8989"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga3de6d881012e9d67a5ebd877baca8989">chrono::irrlicht::addChBodySceneNode_easyCylinder</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, double mmass=1.0, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), const ChVector&lt;&gt; &amp;size=ChVector&lt;&gt;(1, 1, 1), irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga3de6d881012e9d67a5ebd877baca8989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a cylinder, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier).  <a href="group__irrlicht__module.html#ga3de6d881012e9d67a5ebd877baca8989">More...</a><br /></td></tr>
<tr class="separator:ga3de6d881012e9d67a5ebd877baca8989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9660589112f36145978ce33b2c26b9"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga1c9660589112f36145978ce33b2c26b9">chrono::irrlicht::addChBodySceneNode_easyBarrel</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, double mmass=1.0, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), double mradiusH=1.0, double mradiusV=1.0, double mYlow=-0.5, double mYhigh=0.8, double mOffset=0.0, int Hslices=15, int Vslices=10, irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga1c9660589112f36145978ce33b2c26b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a barrel, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier).  <a href="group__irrlicht__module.html#ga1c9660589112f36145978ce33b2c26b9">More...</a><br /></td></tr>
<tr class="separator:ga1c9660589112f36145978ce33b2c26b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ddc60da9ddd71d61b55a4a9a172553"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga83ddc60da9ddd71d61b55a4a9a172553">chrono::irrlicht::addChBodySceneNode_easyClone</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, ChBodySceneNode *source, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga83ddc60da9ddd71d61b55a4a9a172553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function that creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a clone of another <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a>, but at a different position and rotation.  <a href="group__irrlicht__module.html#ga83ddc60da9ddd71d61b55a4a9a172553">More...</a><br /></td></tr>
<tr class="separator:ga83ddc60da9ddd71d61b55a4a9a172553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c6aac1df7f5e044ef22596f214e5e5"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga76c6aac1df7f5e044ef22596f214e5e5">chrono::irrlicht::addChBodySceneNode_easyGenericMesh</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, double mmass=1.0, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), const char *mesh_filemane=0, bool is_static=true, bool is_convex=true, irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga76c6aac1df7f5e044ef22596f214e5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a GENERIC mesh of arbitrary shape, loaded from file using the Irrlicht formats (.obj, .3ds, .X, etc) ready to use for collisions.  <a href="group__irrlicht__module.html#ga76c6aac1df7f5e044ef22596f214e5e5">More...</a><br /></td></tr>
<tr class="separator:ga76c6aac1df7f5e044ef22596f214e5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a8ee19e19ae04d2e4fede88d1011e1"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gad6a8ee19e19ae04d2e4fede88d1011e1">chrono::irrlicht::addChBodySceneNode_easyStaticMesh</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, const char *mesh_filename, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:gad6a8ee19e19ae04d2e4fede88d1011e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a STATIC shape, as a mesh loaded from file using the Irrlicht formats (.obj, .3ds, .X, etc).  <a href="group__irrlicht__module.html#gad6a8ee19e19ae04d2e4fede88d1011e1">More...</a><br /></td></tr>
<tr class="separator:gad6a8ee19e19ae04d2e4fede88d1011e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga102bf095798fbdaa27adfa873db35b3a"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga102bf095798fbdaa27adfa873db35b3a">chrono::irrlicht::addChBodySceneNode_easyConvexMesh</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, const char *mesh_filename, double mmass, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga102bf095798fbdaa27adfa873db35b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a CONVEX shape, as a mesh loaded from file using the Irrlicht formats (.obj, .3ds, .X, etc).  <a href="group__irrlicht__module.html#ga102bf095798fbdaa27adfa873db35b3a">More...</a><br /></td></tr>
<tr class="separator:ga102bf095798fbdaa27adfa873db35b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc67e0e6cf1ab1cfe18ed45149912206"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gabc67e0e6cf1ab1cfe18ed45149912206">chrono::irrlicht::addChBodySceneNode_easyConcaveMesh</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, const char *mesh_filename, double mmass, const ChVector&lt;&gt; &amp;position=ChVector&lt;&gt;(0, 0, 0), const ChQuaternion&lt;&gt; &amp;rotation=ChQuaternion&lt;&gt;(1, 0, 0, 0), irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:gabc67e0e6cf1ab1cfe18ed45149912206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a CONCAVE shape, as a mesh loaded from file using the Irrlicht formats (.obj, .3ds, .X, etc).  <a href="group__irrlicht__module.html#gabc67e0e6cf1ab1cfe18ed45149912206">More...</a><br /></td></tr>
<tr class="separator:gabc67e0e6cf1ab1cfe18ed45149912206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72953facaca0b7621934d64a801047e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf72953facaca0b7621934d64a801047e"></a>
irr::core::array&lt; SDefineExp &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::grabDefineExpressions</b> (irr::core::stringc &amp;shaderProgram)</td></tr>
<tr class="separator:gaf72953facaca0b7621934d64a801047e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03954dbd503bc5f551dbccc97557c1eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03954dbd503bc5f551dbccc97557c1eb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::getFileContent</b> (const std::string pFile)</td></tr>
<tr class="separator:ga03954dbd503bc5f551dbccc97557c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83541e49838a8106275a3865ede47463"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83541e49838a8106275a3865ede47463"></a>
ChApiIrr irr::scene::IAnimatedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga83541e49838a8106275a3865ede47463">chrono::irrlicht::createEllipticalMesh</a> (irr::f32 radiusH, irr::f32 radiusV, irr::f32 Ylow, irr::f32 Yhigh, irr::f32 offset, irr::u32 polyCountX, irr::u32 polyCountY)</td></tr>
<tr class="memdesc:ga83541e49838a8106275a3865ede47463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some functions to allow easy creation of meshes for Irrlicht visualization. <br /></td></tr>
<tr class="separator:ga83541e49838a8106275a3865ede47463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31fd87ff60ce57d03acbf56a8f55e88f"><td class="memItemLeft" align="right" valign="top">IMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga31fd87ff60ce57d03acbf56a8f55e88f">chrono::irrlicht::createCubeMesh</a> (const irr::core::vector3df &amp;size)</td></tr>
<tr class="memdesc:ga31fd87ff60ce57d03acbf56a8f55e88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__irrlicht__module.html#ga31fd87ff60ce57d03acbf56a8f55e88f" title="Same as irr::CGeomentryCreator::createCubeMesh(), but with no shared normals between faces...">irr::CGeomentryCreator::createCubeMesh()</a>, but with no shared normals between faces.  <a href="group__irrlicht__module.html#ga31fd87ff60ce57d03acbf56a8f55e88f">More...</a><br /></td></tr>
<tr class="separator:ga31fd87ff60ce57d03acbf56a8f55e88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf323a6f90005ee5bf87e5c1a584a95c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf323a6f90005ee5bf87e5c1a584a95c5"></a>
ChApiIrr irr::scene::IMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gaf323a6f90005ee5bf87e5c1a584a95c5">chrono::irrlicht::createCylinderMesh</a> (irr::f32 radius, irr::f32 length, irr::u32 tesselation)</td></tr>
<tr class="memdesc:gaf323a6f90005ee5bf87e5c1a584a95c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group__irrlicht__module.html#gaf323a6f90005ee5bf87e5c1a584a95c5" title="Same as irr::CGeomentryCreator::createCylinderMesh(), but with no shared normals between caps and hul...">irr::CGeomentryCreator::createCylinderMesh()</a>, but with no shared normals between caps and hull. <br /></td></tr>
<tr class="separator:gaf323a6f90005ee5bf87e5c1a584a95c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac7cdee7f17c40dc3650aca58df3003"><td class="memItemLeft" align="right" valign="top">ChApiIrr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gaeac7cdee7f17c40dc3650aca58df3003">chrono::irrlicht::fillChTrimeshFromIrlichtMesh</a> (geometry::ChTriangleMesh *chTrimesh, irr::scene::IMesh *pMesh)</td></tr>
<tr class="memdesc:gaeac7cdee7f17c40dc3650aca58df3003"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is based on a modified version of the irrlicht_bullet demo, see <a href="http://www.continuousphysics.com">http://www.continuousphysics.com</a> It is used to convert an Irrlicht mesh into a ChTriangleMesh, which is used for collision detection in Chrono::Engine.  <a href="group__irrlicht__module.html#gaeac7cdee7f17c40dc3650aca58df3003">More...</a><br /></td></tr>
<tr class="separator:gaeac7cdee7f17c40dc3650aca58df3003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad603c246dc6a7fcf27ed78c96e4603b0"><td class="memItemLeft" align="right" valign="top">ChApiIrr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gad603c246dc6a7fcf27ed78c96e4603b0">chrono::irrlicht::fillIrlichtMeshFromChTrimesh</a> (irr::scene::IMesh *pMesh, geometry::ChTriangleMesh *chTrimesh, irr::video::SColor clr=irr::video::SColor(255, 255, 255, 255))</td></tr>
<tr class="memdesc:gad603c246dc6a7fcf27ed78c96e4603b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a ChTriangleMesh object, computes an Irrlicht mesh.  <a href="group__irrlicht__module.html#gad603c246dc6a7fcf27ed78c96e4603b0">More...</a><br /></td></tr>
<tr class="separator:gad603c246dc6a7fcf27ed78c96e4603b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2c3879d095dc35ee2060613bd4d372"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga1b2c3879d095dc35ee2060613bd4d372">chrono::irrlicht::addChParticlesSceneNode</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, irr::scene::IAnimatedMesh *amesh, irr::core::vector3df amesh_scale, double mmass=1.0, irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga1b2c3879d095dc35ee2060613bd4d372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_particles_scene_node.html" title="Definition of an Irrlicht scene node for particles. ">ChIrrParticlesSceneNode</a> and inserts it into the Irrlicht scene.  <a href="group__irrlicht__module.html#ga1b2c3879d095dc35ee2060613bd4d372">More...</a><br /></td></tr>
<tr class="separator:ga1b2c3879d095dc35ee2060613bd4d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c3edcb6e4f16c878ad19f6b0429441"><td class="memItemLeft" align="right" valign="top">ChApiIrr irr::scene::ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga85c3edcb6e4f16c878ad19f6b0429441">chrono::irrlicht::addChParticlesSceneNode_easySpheres</a> (ChSystem *asystem, irr::scene::ISceneManager *amanager, double mmass=1.0, double mradius=1.0, int Hslices=12, int Vslices=6, irr::scene::ISceneNode *aparent=0, irr::s32 mid=-1)</td></tr>
<tr class="memdesc:ga85c3edcb6e4f16c878ad19f6b0429441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_particles_scene_node.html" title="Definition of an Irrlicht scene node for particles. ">ChIrrParticlesSceneNode</a> representing a cluster of particles, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier).  <a href="group__irrlicht__module.html#ga85c3edcb6e4f16c878ad19f6b0429441">More...</a><br /></td></tr>
<tr class="separator:ga85c3edcb6e4f16c878ad19f6b0429441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ed17bda6d256f4239dd473acb3dfde8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ed17bda6d256f4239dd473acb3dfde8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::CShaderPreprocessor::CShaderPreprocessor</b> (irr::video::IVideoDriver *driverIn)</td></tr>
<tr class="separator:ga7ed17bda6d256f4239dd473acb3dfde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa087b60f8ef090ec86d21d9b6cfaa5d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa087b60f8ef090ec86d21d9b6cfaa5d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::CShaderPreprocessor::addShaderDefine</b> (const irr::core::stringc name, const irr::core::stringc value=&quot;&quot;)</td></tr>
<tr class="separator:gaa087b60f8ef090ec86d21d9b6cfaa5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9a6392e711c35ff89c6ececb2a36ab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9a6392e711c35ff89c6ececb2a36ab1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::CShaderPreprocessor::removeShaderDefine</b> (const irr::core::stringc name)</td></tr>
<tr class="separator:gaf9a6392e711c35ff89c6ececb2a36ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46466e5e819cd73b53c4c8b5ef3d105e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga46466e5e819cd73b53c4c8b5ef3d105e"></a>
irr::core::stringc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga46466e5e819cd73b53c4c8b5ef3d105e">chrono::irrlicht::CShaderPreprocessor::ppShader</a> (irr::core::stringc shaderProgram)</td></tr>
<tr class="memdesc:ga46466e5e819cd73b53c4c8b5ef3d105e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PreProcesses a shader using Irrlicht's built-in shader preprocessor. <br /></td></tr>
<tr class="separator:ga46466e5e819cd73b53c4c8b5ef3d105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382da39ce558572c59a01a174e60daf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga382da39ce558572c59a01a174e60daf7"></a>
irr::core::stringc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga382da39ce558572c59a01a174e60daf7">chrono::irrlicht::CShaderPreprocessor::ppShaderFF</a> (irr::core::stringc shaderProgram)</td></tr>
<tr class="memdesc:ga382da39ce558572c59a01a174e60daf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PreProcesses a shader using Irrlicht's built-in shader preprocessor. <br /></td></tr>
<tr class="separator:ga382da39ce558572c59a01a174e60daf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07eee4eb4ca74794431e6c9f18a486f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07eee4eb4ca74794431e6c9f18a486f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::EffectHandler::EffectHandler</b> (irr::IrrlichtDevice *irrlichtDevice, const irr::core::dimension2du &amp;screenRTTSize=irr::core::dimension2du(0, 0), const bool useVSMShadows=false, const bool useRoundSpotLights=false, const bool use32BitDepthBuffers=false)</td></tr>
<tr class="separator:ga07eee4eb4ca74794431e6c9f18a486f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0f96cbdbc1ea6b66c135de3bfd9fdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc0f96cbdbc1ea6b66c135de3bfd9fdd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gabc0f96cbdbc1ea6b66c135de3bfd9fdd">chrono::irrlicht::EffectHandler::~EffectHandler</a> ()</td></tr>
<tr class="memdesc:gabc0f96cbdbc1ea6b66c135de3bfd9fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:gabc0f96cbdbc1ea6b66c135de3bfd9fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc3b6dbe7b565dca0125cf99f4bf440c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc3b6dbe7b565dca0125cf99f4bf440c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gadc3b6dbe7b565dca0125cf99f4bf440c">chrono::irrlicht::EffectHandler::setScreenRenderTargetResolution</a> (const irr::core::dimension2du &amp;resolution)</td></tr>
<tr class="memdesc:gadc3b6dbe7b565dca0125cf99f4bf440c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new screen render target resolution. <br /></td></tr>
<tr class="separator:gadc3b6dbe7b565dca0125cf99f4bf440c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809dc24886dd4884648b479fdba588b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga809dc24886dd4884648b479fdba588b6">chrono::irrlicht::EffectHandler::enableDepthPass</a> (bool enableDepthPass)</td></tr>
<tr class="memdesc:ga809dc24886dd4884648b479fdba588b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables an additional pass before applying post processing effects (If there are any) which records screen depth info to the depth buffer for use with post processing effects that require screen depth info, such as SSAO or DOF.  <a href="#ga809dc24886dd4884648b479fdba588b6">More...</a><br /></td></tr>
<tr class="separator:ga809dc24886dd4884648b479fdba588b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb32bcb50f788927c6b69de74a7e3d01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gabb32bcb50f788927c6b69de74a7e3d01">chrono::irrlicht::EffectHandler::addPostProcessingEffect</a> (irr::s32 MaterialType, IPostProcessingRenderCallback *callback=0)</td></tr>
<tr class="memdesc:gabb32bcb50f788927c6b69de74a7e3d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very easy to use post processing function.  <a href="#gabb32bcb50f788927c6b69de74a7e3d01">More...</a><br /></td></tr>
<tr class="separator:gabb32bcb50f788927c6b69de74a7e3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e09b23d6e288e13df172c8d6c5e8aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga19e09b23d6e288e13df172c8d6c5e8aa">chrono::irrlicht::EffectHandler::addShadowToNode</a> (irr::scene::ISceneNode *node, E_FILTER_TYPE filterType=EFT_NONE, E_SHADOW_MODE shadowMode=ESM_BOTH)</td></tr>
<tr class="memdesc:ga19e09b23d6e288e13df172c8d6c5e8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a shadow to the scene node.  <a href="#ga19e09b23d6e288e13df172c8d6c5e8aa">More...</a><br /></td></tr>
<tr class="separator:ga19e09b23d6e288e13df172c8d6c5e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf622503f8c2fe3811de75c5a3a32aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gadf622503f8c2fe3811de75c5a3a32aaf">chrono::irrlicht::EffectHandler::addNodeToDepthPass</a> (irr::scene::ISceneNode *node)</td></tr>
<tr class="memdesc:gadf622503f8c2fe3811de75c5a3a32aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is now unrelated to shadow mapping.  <a href="#gadf622503f8c2fe3811de75c5a3a32aaf">More...</a><br /></td></tr>
<tr class="separator:gadf622503f8c2fe3811de75c5a3a32aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0e24f66d7ba9532f7942ed20305e71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gaeb0e24f66d7ba9532f7942ed20305e71">chrono::irrlicht::EffectHandler::removeNodeFromDepthPass</a> (irr::scene::ISceneNode *node)</td></tr>
<tr class="memdesc:gaeb0e24f66d7ba9532f7942ed20305e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is now unrelated to shadow mapping.  <a href="#gaeb0e24f66d7ba9532f7942ed20305e71">More...</a><br /></td></tr>
<tr class="separator:gaeb0e24f66d7ba9532f7942ed20305e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64c9b9a352ca747e67886ba25bc236d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gac64c9b9a352ca747e67886ba25bc236d">chrono::irrlicht::EffectHandler::update</a> (irr::video::ITexture *outputTarget=0)</td></tr>
<tr class="memdesc:gac64c9b9a352ca747e67886ba25bc236d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the effects handler.  <a href="#gac64c9b9a352ca747e67886ba25bc236d">More...</a><br /></td></tr>
<tr class="separator:gac64c9b9a352ca747e67886ba25bc236d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c148333706a83c45e03302532df5ee"><td class="memItemLeft" align="right" valign="top">irr::video::ITexture *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga38c148333706a83c45e03302532df5ee">chrono::irrlicht::EffectHandler::getShadowMapTexture</a> (const irr::u32 resolution, const bool secondary=false)</td></tr>
<tr class="memdesc:ga38c148333706a83c45e03302532df5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shadow map texture for the specified square shadow map resolution.  <a href="#ga38c148333706a83c45e03302532df5ee">More...</a><br /></td></tr>
<tr class="separator:ga38c148333706a83c45e03302532df5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaba0113af331876f3a9e891e387fd92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadaba0113af331876f3a9e891e387fd92"></a>
irr::video::ITexture *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#gadaba0113af331876f3a9e891e387fd92">chrono::irrlicht::EffectHandler::generateRandomVectorTexture</a> (const irr::core::dimension2du &amp;dimensions, const irr::core::stringc &amp;name=&quot;randVec&quot;)</td></tr>
<tr class="memdesc:gadaba0113af331876f3a9e891e387fd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a randomized texture composed of uniformly distributed 3 dimensional vectors. <br /></td></tr>
<tr class="separator:gadaba0113af331876f3a9e891e387fd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006d6615ff19b98a44d8b890c6d69d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga006d6615ff19b98a44d8b890c6d69d61">chrono::irrlicht::EffectHandler::setPostProcessingEffectConstant</a> (const irr::s32 materialType, const irr::core::stringc &amp;name, const irr::f32 *data, const irr::u32 count)</td></tr>
<tr class="memdesc:ga006d6615ff19b98a44d8b890c6d69d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a shader parameter for a post-processing effect.  <a href="#ga006d6615ff19b98a44d8b890c6d69d61">More...</a><br /></td></tr>
<tr class="separator:ga006d6615ff19b98a44d8b890c6d69d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826eb1e6f5be03ab2c924450541ddf76"><td class="memItemLeft" align="right" valign="top">irr::s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga826eb1e6f5be03ab2c924450541ddf76">chrono::irrlicht::EffectHandler::addPostProcessingEffectFromFile</a> (const irr::core::stringc &amp;filename, IPostProcessingRenderCallback *callback=0)</td></tr>
<tr class="memdesc:ga826eb1e6f5be03ab2c924450541ddf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a post processing effect by reading a pixel shader from a file.  <a href="#ga826eb1e6f5be03ab2c924450541ddf76">More...</a><br /></td></tr>
<tr class="separator:ga826eb1e6f5be03ab2c924450541ddf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7149188f9b8e1f7052c2d2ccf621b44b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__irrlicht__module.html#ga7149188f9b8e1f7052c2d2ccf621b44b">chrono::irrlicht::ScreenQuadCB::OnSetConstants</a> (irr::video::IMaterialRendererServices *services, irr::s32 userData)</td></tr>
<tr class="separator:ga7149188f9b8e1f7052c2d2ccf621b44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7ba75cdc58259ac9688531a100df569d"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::LIGHT_MODULATE_P</b> [ESE_COUNT]</td></tr>
<tr class="separator:ga7ba75cdc58259ac9688531a100df569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a6e9cd595140245351c409db81ffb4"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::SHADOW_PASS_1P</b> [ESE_COUNT]</td></tr>
<tr class="separator:ga49a6e9cd595140245351c409db81ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5db0ff32f58e8084ebf3e0d94ea6a9a"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::SHADOW_PASS_1PT</b> [ESE_COUNT]</td></tr>
<tr class="separator:gae5db0ff32f58e8084ebf3e0d94ea6a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c528d9629905f8817756029bf55594"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga17c528d9629905f8817756029bf55594"></a>
const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::SHADOW_PASS_1V</b> [ESE_COUNT]</td></tr>
<tr class="separator:ga17c528d9629905f8817756029bf55594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99d80ccd1a196a093281ac614834fa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad99d80ccd1a196a093281ac614834fa0"></a>
const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::SHADOW_PASS_2P</b> [ESE_COUNT]</td></tr>
<tr class="separator:gad99d80ccd1a196a093281ac614834fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7203b88608d25abb0d6385cd9d0379"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b7203b88608d25abb0d6385cd9d0379"></a>
const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::SHADOW_PASS_2V</b> [ESE_COUNT]</td></tr>
<tr class="separator:ga1b7203b88608d25abb0d6385cd9d0379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f097bfb610833e396de290c51397bd7"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::SIMPLE_P</b> [ESE_COUNT]</td></tr>
<tr class="separator:ga4f097bfb610833e396de290c51397bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299698b75e080a82e0b853bf7f88660f"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::WHITE_WASH_P</b> [ESE_COUNT]</td></tr>
<tr class="separator:ga299698b75e080a82e0b853bf7f88660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b7076da09635f283d8460ea55a77c5"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::WHITE_WASH_P_ADD</b> [ESE_COUNT]</td></tr>
<tr class="separator:ga10b7076da09635f283d8460ea55a77c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab350f3ffe2dd0824e556d954605e1700"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab350f3ffe2dd0824e556d954605e1700"></a>
const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::SCREEN_QUAD_V</b> [ESE_COUNT]</td></tr>
<tr class="separator:gab350f3ffe2dd0824e556d954605e1700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab89f9c846ef329c6b0833aa097b32a39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab89f9c846ef329c6b0833aa097b32a39"></a>
const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>chrono::irrlicht::VSM_BLUR_P</b> [ESE_COUNT]</td></tr>
<tr class="separator:gab89f9c846ef329c6b0833aa097b32a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga4d7e2f7bdfa610d6bbf8c7970d1f4eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__irrlicht__module.html#ga4d7e2f7bdfa610d6bbf8c7970d1f4eb3">chrono::irrlicht::E_SHADOW_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow mode enums, sets whether a node recieves shadows, casts shadows, or both. </p>
<p>If the mode is ESM_CAST, it will not be affected by shadows or lighting. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac6699f10e69950ed4297b873b702e6c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::IAnimatedMesh *&#160;</td>
          <td class="paramname"><em>amesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> with given position of COG, inserts it into the Irrlicht scene etc. </p>

</div>
</div>
<a class="anchor" id="ga1c9660589112f36145978ce33b2c26b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easyBarrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mradiusH</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mradiusV</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mYlow</em> = <code>-0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mYhigh</em> = <code>0.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mOffset</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Hslices</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Vslices</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a barrel, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier). </p>
<p>The returned object has collision detection turned ON by default. </p>

</div>
</div>
<a class="anchor" id="ga88caf7f14bd9e3ec92b5f4738e43441f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easyBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(1,&#160;1,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a box, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier). </p>
<p>The returned object has collision detection turned ON by default. </p>

</div>
</div>
<a class="anchor" id="ga83ddc60da9ddd71d61b55a4a9a172553"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easyClone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html">ChBodySceneNode</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function that creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a clone of another <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a>, but at a different position and rotation. </p>
<p>NOTE! the collision shapes (if any) in the source object will be <em>shared</em> with the cloned object, so if you have to create for exampe 1000 identical objects (ex. cubes) this function will allow you to replicate 999 times a single cube that you once created calling <a class="el" href="group__irrlicht__module.html#ga88caf7f14bd9e3ec92b5f4738e43441f" title="Easy-to-use function which creates a ChBodySceneNode representing a box, ready to use for collisions ...">addChBodySceneNode_easyBox()</a>: this will be more memory-efficient than calling many times the function <a class="el" href="group__irrlicht__module.html#ga88caf7f14bd9e3ec92b5f4738e43441f" title="Easy-to-use function which creates a ChBodySceneNode representing a box, ready to use for collisions ...">addChBodySceneNode_easyBox()</a>. Shared geometries will be deallocated automatically thank to shared pointers. </p>

</div>
</div>
<a class="anchor" id="gabc67e0e6cf1ab1cfe18ed45149912206"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easyConcaveMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a CONCAVE shape, as a mesh loaded from file using the Irrlicht formats (.obj, .3ds, .X, etc). </p>
<p>The mesh can be moving. The loaded mesh is used BOTH for display in Irrlicht 3d view and for collision. The returned object has collision detection turned ON by default. Works also for convex shapes, but the performance is not as fast and robust as in case of native convex cases, so whenever possible use addChBodySceneNode_easyConvexMesh. </p>

</div>
</div>
<a class="anchor" id="ga102bf095798fbdaa27adfa873db35b3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easyConvexMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a CONVEX shape, as a mesh loaded from file using the Irrlicht formats (.obj, .3ds, .X, etc). </p>
<p>The mesh can be moving. If mesh is not concave or has holes/gaps, its convex hull is used anyway. Best used with <em>simple</em> meshes, not too many points. The loaded mesh is used BOTH for display in Irrlicht 3d view and for collision. The returned object has collision detection turned ON by default. </p>

</div>
</div>
<a class="anchor" id="ga3de6d881012e9d67a5ebd877baca8989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easyCylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(1,&#160;1,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a cylinder, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier). </p>
<p>The returned object has collision detection turned ON by default. </p>

</div>
</div>
<a class="anchor" id="ga76c6aac1df7f5e044ef22596f214e5e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easyGenericMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mesh_filemane</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_static</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_convex</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a GENERIC mesh of arbitrary shape, loaded from file using the Irrlicht formats (.obj, .3ds, .X, etc) ready to use for collisions. </p>
<p>The loaded mesh is used BOTH for display in Irrlicht 3d view and for collision. The returned object has collision detection turned ON by default. </p>

</div>
</div>
<a class="anchor" id="ga430a3c13a142d932ed9e7184d7c10455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easySphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mradius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Hslices</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Vslices</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a sphere, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier). </p>
<p>The returned object has collision detection turned ON by default. </p>

</div>
</div>
<a class="anchor" id="gad6a8ee19e19ae04d2e4fede88d1011e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_easyStaticMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_body_scene_node.html" title="Irrlicht scene node for a body. ">ChBodySceneNode</a> representing a STATIC shape, as a mesh loaded from file using the Irrlicht formats (.obj, .3ds, .X, etc). </p>
<p>The mesh can be either convex or concave: it works anyway (but it should NOT move!) The loaded mesh is used BOTH for display in Irrlicht 3d view and for collision. The returned object has collision detection turned ON by default. The returned object is fixed by default (no need to do SetBodyFixed(true) ). </p>

</div>
</div>
<a class="anchor" id="gab5ba3126f6cfe0dc572e1cb26749f551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChBodySceneNode_offsetCOG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::IAnimatedMesh *&#160;</td>
          <td class="paramname"><em>amesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_position</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="classchrono_1_1_ch_quaternion.html">ChQuaternion</a>&lt;&gt;(1,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>COG_offset</em> = <code><a class="el" href="classchrono_1_1_ch_vector.html">ChVector</a>&lt;&gt;(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but allow user to specify an offset distance between COG and mesh location. </p>
<p>Note: the mesh remains in the same location, but the COG of the rigid body changes by the offset amount. </p>

</div>
</div>
<a class="anchor" id="ga1b2c3879d095dc35ee2060613bd4d372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChParticlesSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::IAnimatedMesh *&#160;</td>
          <td class="paramname"><em>amesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::core::vector3df&#160;</td>
          <td class="paramname"><em>amesh_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_particles_scene_node.html" title="Definition of an Irrlicht scene node for particles. ">ChIrrParticlesSceneNode</a> and inserts it into the Irrlicht scene. </p>

</div>
</div>
<a class="anchor" id="ga85c3edcb6e4f16c878ad19f6b0429441"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::ISceneNode* chrono::irrlicht::addChParticlesSceneNode_easySpheres </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1_ch_system.html">ChSystem</a> *&#160;</td>
          <td class="paramname"><em>asystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneManager *&#160;</td>
          <td class="paramname"><em>amanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mmass</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mradius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Hslices</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Vslices</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>aparent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>mid</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Easy-to-use function which creates a <a class="el" href="classchrono_1_1irrlicht_1_1_ch_irr_particles_scene_node.html" title="Definition of an Irrlicht scene node for particles. ">ChIrrParticlesSceneNode</a> representing a cluster of particles, ready to use for collisions (otherwise you could use <a class="el" href="group__irrlicht__module.html#gac6699f10e69950ed4297b873b702e6c9" title="Easy-to-use function which creates a ChBodySceneNode with given position of COG, inserts it into the ...">addChBodySceneNode()</a> and add collision geometry by hand, but the following is easier). </p>
<p>The returned object has collision detection turned ON by default. </p>

</div>
</div>
<a class="anchor" id="gadf622503f8c2fe3811de75c5a3a32aaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chrono::irrlicht::EffectHandler::addNodeToDepthPass </td>
          <td>(</td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is now unrelated to shadow mapping. </p>
<p>It simply adds a node to the screen space depth map render, for use with post processing effects that require screen depth info. If you want the functionality of the old method (A node that only casts but does not recieve shadows, use addShadowToNode with the ESM_CAST shadow mode. </p>

</div>
</div>
<a class="anchor" id="gabb32bcb50f788927c6b69de74a7e3d01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chrono::irrlicht::EffectHandler::addPostProcessingEffect </td>
          <td>(</td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>MaterialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IPostProcessingRenderCallback *&#160;</td>
          <td class="paramname"><em>callback</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A very easy to use post processing function. </p>
<p>Simply add a material type to apply to the screen as a post processing effect and it will be applied. You can add as many material types as you desire, and they will be double buffered and executed in sequance.</p>
<p>For the material types, I recommend using "ScreenQuadCB" as the callback and refering to the texture names that are passed (When using OpenGL, in DirectX uniforms are not required to bind textures). Please note that this will only work in OpenGL on vanilla Irrlicht, DX requires the large RTT patch to be able to create sufficiently sized rendertargets for post processing. (Or you can just remove the engine check for Pow2).</p>
<p>The structure of the textures is as follows:</p>
<p>Texture1 - "ColorMapSampler" This is passed on from the previous post processing effect as they are executed in sequance. For example, if you do a horizontal blur on the first post processing material, then a vertical blur in the second material, you will use this sampler to access the post processed data of the horizontal blur when it is time to do the vertical blur. If accessed from the first post processing material, it will just contain the untainted screen map data.</p>
<p>Texture2 - "ScreenMapSampler" The second texture will always contain the untainted screen map data, from when the scene is first rendered. It will remain unchanged no matter how many post processing materials are applied. This kind of data is necessary, for example in bloom or DOF, you would require a copy of the blurred scene data and a copy of the normal untainted, unblurred screen data, and mix between them based on certain factors such as depth or luminance.</p>
<p>Texture3 - "DepthMapSampler" If a depth pass has been enabled using enableDepthPass, then this sampler will contain the screen space depth information. For better quality this is encoded to 16bits, and can be decoded like so: Texture.red + (Texture.green / 256.0f); That is by adding the red channel to the green channel which is first divided by 256. The data can still be used without decoding, in 8 bit precision, by just accessing the red component of the texture. Though this is not recommended as 8 bit precision is usually not sufficient for modern post processing effects.</p>
<p>Texture4 - "UserMapSampler" A custom texture that can be set by the user using <a class="el" href="classchrono_1_1irrlicht_1_1_effect_handler.html#abcb8ee8132ebdc6cf11149a20531016c" title="This allows the user to specify a custom, fourth texture to be used in the post-processing effects...">setPostProcessingUserTexture(irr::video::ITexture* userTexture)</a>.</p>
<p>The last parameter is the render callback, you may pass 0 if you do not need one. Please see IPostProcessingRenderCallback for more info about this callback. </p>

</div>
</div>
<a class="anchor" id="ga826eb1e6f5be03ab2c924450541ddf76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">irr::s32 chrono::irrlicht::EffectHandler::addPostProcessingEffectFromFile </td>
          <td>(</td>
          <td class="paramtype">const irr::core::stringc &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IPostProcessingRenderCallback *&#160;</td>
          <td class="paramname"><em>callback</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a post processing effect by reading a pixel shader from a file. </p>
<p>The vertex shader is taken care of. The vertex shader will pass the correct screen quad texture coordinates via the TEXCOORD0 semantic in Direct3D or the gl_TexCoord[0] varying in OpenGL. See addPostProcessingEffect for more info. Returns the Irrlicht material type of the post processing effect. </p>

</div>
</div>
<a class="anchor" id="ga19e09b23d6e288e13df172c8d6c5e8aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chrono::irrlicht::EffectHandler::addShadowToNode </td>
          <td>(</td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__irrlicht__module.html#gadf6049603cfa127f42c6bbe78fa889d8">E_FILTER_TYPE</a>&#160;</td>
          <td class="paramname"><em>filterType</em> = <code>EFT_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__irrlicht__module.html#ga4d7e2f7bdfa610d6bbf8c7970d1f4eb3">E_SHADOW_MODE</a>&#160;</td>
          <td class="paramname"><em>shadowMode</em> = <code>ESM_BOTH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a shadow to the scene node. </p>
<p>The filter type specifies how many shadow map samples to take, a higher value can produce a smoother or softer result. The shadow mode can be either ESM_BOTH, ESM_CAST, or ESM_RECEIVE. ESM_BOTH casts and receives shadows, ESM_CAST only casts shadows, and is unaffected by shadows or lighting, and ESM_RECEIVE only receives but does not cast shadows. </p>

</div>
</div>
<a class="anchor" id="ga31fd87ff60ce57d03acbf56a8f55e88f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr irr::scene::IMesh * chrono::irrlicht::createCubeMesh </td>
          <td>(</td>
          <td class="paramtype">const irr::core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__irrlicht__module.html#ga31fd87ff60ce57d03acbf56a8f55e88f" title="Same as irr::CGeomentryCreator::createCubeMesh(), but with no shared normals between faces...">irr::CGeomentryCreator::createCubeMesh()</a>, but with no shared normals between faces. </p>

</div>
</div>
<a class="anchor" id="ga809dc24886dd4884648b479fdba588b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chrono::irrlicht::EffectHandler::enableDepthPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableDepthPass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/disables an additional pass before applying post processing effects (If there are any) which records screen depth info to the depth buffer for use with post processing effects that require screen depth info, such as SSAO or DOF. </p>
<p>For nodes to be rendered in this pass, they must first be added using addNodeToDepthPass(SceneNode). </p>

</div>
</div>
<a class="anchor" id="gaeac7cdee7f17c40dc3650aca58df3003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr void chrono::irrlicht::fillChTrimeshFromIrlichtMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchrono_1_1geometry_1_1_ch_triangle_mesh.html">geometry::ChTriangleMesh</a> *&#160;</td>
          <td class="paramname"><em>chTrimesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::IMesh *&#160;</td>
          <td class="paramname"><em>pMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is based on a modified version of the irrlicht_bullet demo, see <a href="http://www.continuousphysics.com">http://www.continuousphysics.com</a> It is used to convert an Irrlicht mesh into a ChTriangleMesh, which is used for collision detection in Chrono::Engine. </p>

</div>
</div>
<a class="anchor" id="gad603c246dc6a7fcf27ed78c96e4603b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChApiIrr void chrono::irrlicht::fillIrlichtMeshFromChTrimesh </td>
          <td>(</td>
          <td class="paramtype">irr::scene::IMesh *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchrono_1_1geometry_1_1_ch_triangle_mesh.html">geometry::ChTriangleMesh</a> *&#160;</td>
          <td class="paramname"><em>chTrimesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::video::SColor&#160;</td>
          <td class="paramname"><em>clr</em> = <code>irr::video::SColor(255,&#160;255,&#160;255,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a ChTriangleMesh object, computes an Irrlicht mesh. </p>
<p>Note: the ChTriangleMesh is a 'triangle soup', so no connectivity is used. As a consequence, no Gourad/Phong shading is possible and all triangles will look flat.</p>
<p>***OBSOLETE*** </p>

</div>
</div>
<a class="anchor" id="ga38c148333706a83c45e03302532df5ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">irr::video::ITexture * chrono::irrlicht::EffectHandler::getShadowMapTexture </td>
          <td>(</td>
          <td class="paramtype">const irr::u32&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>secondary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the shadow map texture for the specified square shadow map resolution. </p>
<p>Only one shadow map is kept for each resolution, so if multiple lights are using the same resolution, you will only see the last light drawn's output. The secondary param specifies whether to retrieve the secondary shadow map used in blurring. </p>

</div>
</div>
<a class="anchor" id="ga7149188f9b8e1f7052c2d2ccf621b44b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chrono::irrlicht::ScreenQuadCB::OnSetConstants </td>
          <td>(</td>
          <td class="paramtype">irr::video::IMaterialRendererServices *&#160;</td>
          <td class="paramname"><em>services</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Version for Irrlicht 1.7.3 </p>

</div>
</div>
<a class="anchor" id="gaeb0e24f66d7ba9532f7942ed20305e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chrono::irrlicht::EffectHandler::removeNodeFromDepthPass </td>
          <td>(</td>
          <td class="paramtype">irr::scene::ISceneNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is now unrelated to shadow mapping. </p>
<p>It simply removes a node to the screen space depth map render, for use with post processing effects that require screen depth info. </p>

</div>
</div>
<a class="anchor" id="ga006d6615ff19b98a44d8b890c6d69d61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chrono::irrlicht::EffectHandler::setPostProcessingEffectConstant </td>
          <td>(</td>
          <td class="paramtype">const irr::s32&#160;</td>
          <td class="paramname"><em>materialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const irr::core::stringc &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const irr::f32 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const irr::u32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a shader parameter for a post-processing effect. </p>
<p>The first parameter is the material type, the second is the uniform paratmeter name, the third is a float pointer that points to the data and the last is the component count of the data. Please note that the float pointer must remain valid during render time. To disable the setting of a parameter you may simply pass a null float pointer. </p>

</div>
</div>
<a class="anchor" id="gac64c9b9a352ca747e67886ba25bc236d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chrono::irrlicht::EffectHandler::update </td>
          <td>(</td>
          <td class="paramtype">irr::video::ITexture *&#160;</td>
          <td class="paramname"><em>outputTarget</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the effects handler. </p>
<p>This must be done between IVideoDriver::beginScene and IVideoDriver::endScene. This function now replaces smgr-&gt;drawAll(). So place it where smgr-&gt;drawAll() would normally go. Please note that the clear colour from IVideoDriver::beginScene is not preserved, so you must instead specify the clear colour using EffectHandler::setClearColour(Colour). A render target may be passed as the output target, else rendering will commence on the backbuffer. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga7ba75cdc58259ac9688531a100df569d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const chrono::irrlicht::LIGHT_MODULATE_P[ESE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    <span class="stringliteral">&quot;uniform sampler2D ColorMapSampler;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;uniform sampler2D ScreenMapSampler;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;void main() &quot;</span></div><div class="line">    <span class="stringliteral">&quot;{          &quot;</span></div><div class="line">    <span class="stringliteral">&quot;   vec4 finalCol = texture2D(ColorMapSampler, gl_TexCoord[0].xy);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   vec4 lightCol = texture2D(ScreenMapSampler, gl_TexCoord[0].xy);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   gl_FragColor = finalCol * lightCol;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;sampler2D ColorMapSampler : register(s0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;sampler2D ScreenMapSampler : register(s1);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;float4 pixelMain(float2 TexCoords : TEXCOORD0) : COLOR0&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{          &quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float4 finalCol = tex2D(ColorMapSampler, TexCoords);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float4 lightCol = tex2D(ScreenMapSampler, TexCoords);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   return finalCol * lightCol;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga49a6e9cd595140245351c409db81ffb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const chrono::irrlicht::SHADOW_PASS_1P[ESE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    <span class="stringliteral">&quot;void main() &quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   vec4 vInfo = gl_TexCoord[0];\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float depth = vInfo.z / vInfo.x;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   gl_FragColor = vec4(depth, depth * depth, 0.0, 0.0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;float4 pixelMain(float4 ClipPos: TEXCOORD0) : COLOR0&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float depth = ClipPos.z / ClipPos.x;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   return float4(depth, depth * depth, 0.0, 0.0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gae5db0ff32f58e8084ebf3e0d94ea6a9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const chrono::irrlicht::SHADOW_PASS_1PT[ESE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    <span class="stringliteral">&quot;uniform sampler2D ColorMapSampler;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;void main() &quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   vec4 vInfo = gl_TexCoord[0];\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float depth = vInfo.z / vInfo.x;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float alpha = texture2D(ColorMapSampler, gl_TexCoord[1].xy).a;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;    gl_FragColor = vec4(depth, depth * depth, 0.0, alpha);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;sampler2D ColorMapSampler : register(s0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;float4 pixelMain(float4 Color: TEXCOORD0, float2 Texcoords: TEXCOORD1) : COLOR0&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float depth = Color.z / Color.w;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   &quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float alpha = tex2D(ColorMapSampler, Texcoords).a;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   &quot;</span></div><div class="line">    <span class="stringliteral">&quot;   return float4(depth, depth * depth, 0.0, alpha);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga4f097bfb610833e396de290c51397bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const chrono::irrlicht::SIMPLE_P[ESE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    <span class="stringliteral">&quot;uniform sampler2D ColorMapSampler;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;void main() &quot;</span></div><div class="line">    <span class="stringliteral">&quot;{          &quot;</span></div><div class="line">    <span class="stringliteral">&quot;   vec4 finalCol = texture2D(ColorMapSampler, gl_TexCoord[0].xy);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   gl_FragColor = finalCol;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;sampler2D ColorMapSampler : register(s0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;float4 pixelMain(float2 TexCoords : TEXCOORD0) : COLOR0&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{          &quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float4 finalCol = tex2D(ColorMapSampler, TexCoords);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   return finalCol;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga299698b75e080a82e0b853bf7f88660f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const chrono::irrlicht::WHITE_WASH_P[ESE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    <span class="stringliteral">&quot;uniform sampler2D ColorMapSampler;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;void main() &quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float alpha = texture2D(ColorMapSampler, gl_TexCoord[1].xy).a;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;sampler2D ColorMapSampler : register(s0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;float4 pixelMain(float4 Color: TEXCOORD0, float2 Texcoords: TEXCOORD1) : COLOR0&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float alpha = tex2D(ColorMapSampler, Texcoords).a;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   return float4(1.0, 1.0, 1.0, alpha);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga10b7076da09635f283d8460ea55a77c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const chrono::irrlicht::WHITE_WASH_P_ADD[ESE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    <span class="stringliteral">&quot;uniform sampler2D ColorMapSampler;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;float luminance(vec3 color)&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   return clamp(color.r * 0.3 + color.g * 0.59 + color.b * 0.11, 0.0, 1.0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span></div><div class="line">    <span class="stringliteral">&quot;void main() &quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   vec4 diffuseTex = texture2D(ColorMapSampler, gl_TexCoord[1].xy);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   //diffuseTex *= gl_TexCoord[2];\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;    gl_FragColor = vec4(1.0, 1.0, 1.0, luminance(diffuseTex.rgb));\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;sampler2D ColorMapSampler : register(s0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;float luminance(float3 color)&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   return clamp(color.r * 0.3 + color.g * 0.59 + color.b * 0.11, 0.0, 1.0);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;float4 pixelMain(float4 Color : TEXCOORD0, float2 Texcoords : TEXCOORD1, float4 VColor : TEXCOORD2) : COLOR0&quot;</span></div><div class="line">    <span class="stringliteral">&quot;{&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   float4 diffuseTex = tex2D(ColorMapSampler, Texcoords);\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   diffuseTex *= VColor;\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;&quot;</span></div><div class="line">    <span class="stringliteral">&quot;   return float4(1.0, 1.0, 1.0, luminance(diffuseTex.rgb));\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot;}&quot;</span>}</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 1 2016 15:43:12 for Project Chrono by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11 . <a href="mailto:info@projectchrono.org">Contact us</a> for issues related to this page. 
</small></address>
</body>
</html>
